---
title: tips
date: 2023-10-21 17:16:59
categories: 
- C语言
tags: 
- 位运算
cover: /pic/1.png

---


# 1. 全局变量的作用域
---

> ***全局变量的作用域就是整个工程***

我们在**同一工程**但在**不同的源文件**这句话是否有误呢?

比如在源文件 test2.c 中我们创建一个全局变量  a = 10
![](/img/1.1.png)


但在**不做声名**的情况下我们却发现在test1.c中   a    并没有被创建
![](/img/1.2.png)

但是全局变量的作用域是整个工程这句话并没有错误

我们只需要在 test2.c 中声明即可

此时我们需要一个函数 extern  使用方法如下
![](/img/1.3.png)




---
# 2. 什么是常量
---
创建数组时我们需要为数组提供 创建量(必须为常量)
![](/img/1.4.png)


---
## 2.1 const
---
> const在 * 前 , 修饰的是 *p 
> const在 * 后 , 修饰的是  p 


![](/img/1.5.png)

**`const 只是将 a 从变量修饰成了常量,让其拥有了常属性,但其本质上还是一个变量  `**

![](/img/1.6.png)



---

## 2.2 枚举常量

> 枚举常量即是可以一一列举的量

创建方法如下

```c
enum xxx
{
   a,       //若不赋值默认为0
   b,       //向下逐一递增,b即默认为1
   c = 100, //赋值之后即为100
   d        //逐一递增,默认为101
}
```

![](/img/1.7.png)

可以看到 d 并不能改变

---

# 3. 字符串
---
## 3.1 常见字符串的创建
---
常见的字符串创建有以下几种
```c
char arr1[] = "abc";              //实际上该字符串共有4个元素,其末尾会自动补上'\0'作为终止标志
char arr2[] = {'a','b','c','\0'}; //以这种方式创建时必须手动补上 '\0'作为结束标志
char arr3[4] = "abc"              //之所以要标有四个元素个数,是要为 '\0' 留有空间
char arr4[4] = {'a','b','c','\0'}
char arr5[4] = {'a','b','c'}      //此时不加'\0'也没有关系,剩下的元素自动默认为'\0'
```
那么,加入没有手动加入  **'\0'**   arr2 是否会出问题呢,我们来使用 **strlen** 这个函数来验证一下

---
## 3.2 strlen简介
---

> 求长度方式就是计算出字符串 '\0' 前的字符个数(不包括'\0')

![](/img/1.8.png)
可见没有手动加入 '\0' 之后该字符串的长度是42(随机值)

---

# 4. 转义字符
**前言**:当我们想要打印一个字符 ' 时会发现如下错误

![](/img/1.9.png)
那么究竟该如何做才能打印出一些貌似有功能作用的字符呢
在此我们引出**转义字符**

|转义字符 |作用 |
|--|--|
| /' |用于表示字符常量 '  |
| /"|用于表示一个字符串内的双引号 |
|// |用于表示一个反斜杠,防止被解释为一个 转义序列符(即 /n , /r 等解释方向) |
|/a |警告字符,打印可发出蜂鸣声 |
|/b |退格符 |
|/f |进纸符 |
|/n |换行 |
|/r |回车 |
| /t| 水平制表符|
| /t| 水平制表符|
| /v| 垂直制表符|
| /ddd|(d表示随机数字)表示1~3个八进制数字(系统可以将他解读为十进制 比如 /130 系统可以将他解释为十进制的 88|
| /xdd|(/x是头,d是随机数字)表示1~2个十六进制数字 |


---


# 5. 关键字
---

`注意: define 和 include 并不是关键字 而是预处理指令`

---

## 5.1 static
---
> **static修饰局部变量,改变了局部变量的生命周期 ,本质上是改变了变量的存储类型(由栈区变为静态区)**
> **static也会使其修饰的全局变量只能在自己所在的源文件内使用,其他源文件不能使用**

如下:
![](/img/1.10.png)

> 全局变量在其他源文件内可以使用的原因是其具有**外部链接属性**
> 但被static修饰后,就变成了**内部链接属性**,其他源文件就不能链接到这个静态的全局变量了
> **static修饰函数**时,也会使得函数只能在自己所在的源文件内部使用

---
## 5.2 goto
---

> goto语句不能够跨越函数



```c
void test()
{
   flag:
   printf("aaa");
}
int main()
{
    goto flag; //此时的flag会报错出"未定义flag"
    return 0;
}    
```

---


# 6. 随机数(时间戳)的生成
---
## 6.1 rand 函数
rand函数的模型为

> #include<stdilb.h>
> .
>  int rand(void);

该函数可以生成 0~32767 的整形数

**但是,调用该数组生成的虽然确实是一个随机数,但是当你运行第二次时,这个随机数并没有发生变化**

第一次调用:
![](/img/1.11.png)

第二次调用:
![](/img/1.12.png)


我们引入另外一个函数

---

## 6.2 srand 函数
---

> 调用rand之前,我们需要调用srand来设置这个随机数的生成器

其模型为

> #include<stdlib.h> 
> .
> void srand(unsigned int seed);

但是当我们调用这个函数后并放入一个 unsigned int 整形数后却发现

![](/img/1.13.png)

较上次不一样了
调用第二次却发现,数字还是没有变化

再引入一个库函数

---
## 6.3 time函数
---

> time函数会返回一个时间戳,返回的时间戳是:
> 调用这个函数的那个时间点和计算机的起始时间之间的时间戳

其模型为:

> #include<time.h> 
> . 
> time_t time(time_t *timer);    //time_t 本质上是一个整形

而srand需要的类型是 unsigned int 类型,那么强制转换一下

```c
#include<stdlib.h>
#include<time.h>
int main()
{
  srand((unsigned int)time(NULL));
  int ret = rand(); //ret 即是我们需要的随机数
  return 0;
}
```
---




# 7. 栈区存储习惯先高地址后低地址

> 栈区的存储习惯为
> 先使用高地址再使用低地址

---


# 8. 位操作符
---
## 8.1 >>  、<<   (右移操作符和左移操作符)
---

>  .>> 是数字向低位移动
> .<< 是数字向高位移动

注意:以下写法为错误且编译器无法处理的
```c
int a = 10;
int b = a >> -3 ; //error
```

---

## 8.2 & (按位与)

---

> 有0为0
> 全1为1
---

## 8.3 |  (按位或)
---



> 有1为1
> 全0为0

---

## 8.4 ^ (按位异或)
---

按位异或的规则是

> 相同为0 
> 相异为1

---



## 8.5 ~ (按位取反)

> 按位取反是对其补码进行处理
